using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text.Json;

namespace FirstWebApplication1.Models
{
    /// <summary>
    /// Domain model (the "Model" in MVC) representing a reported obstacle. Instances are persisted via
    /// EF Core and bound in controllers/views. Validation attributes protect data integrity and help
    /// guard against XSS by constraining input lengths and types before the values reach the view.
    /// </summary>
    public class ObstacleData : IValidatableObject
    {
        /// <summary>
        /// Primary key generated by the database; used by controllers for lookups and routing.
        /// </summary>
        [Key]
        public int Id { get; set; }

        /// <summary>
        /// Optional category chosen during step 1; helps filter obstacles by type.
        /// </summary>
        [StringLength(50)]
        [MaxLength(300, ErrorMessage = "Description cannot exceed 300 characters.")]
        public string? ObstacleType { get; set; }

        /// <summary>
        /// Display name shown in lists and details; defaults to the selected type.
        /// </summary>
        [Required(ErrorMessage = "Obstacle name is required")]
        [StringLength(100, ErrorMessage = "Max 100 characters")]
        public string? ObstacleName { get; set; }

        /// <summary>
        /// Height of the obstacle in meters. Validation mirrors business rule enforced in controllers.
        /// </summary>
        [Required(ErrorMessage = "Height is required")]
        [Range(15, 300, ErrorMessage = "Height must be between 15 and 300 meters")]
        public double ObstacleHeight { get; set; }

        /// <summary>
        /// Helper property for presenting height in feet to pilots while persisting meters in the DB.
        /// </summary>
        [NotMapped]
        public double ObstacleHeightInFeet
        {
            get => ObstacleHeight * 3.28084; // Convert meters to feet for UI consumption.
            set => ObstacleHeight = value / 3.28084; // Convert feet back to meters for persistence.
        }

        /// <summary>
        /// Free-text description used in detail views; length constrained to mitigate XSS risk.
        /// </summary>
        [StringLength(1000, ErrorMessage = "Max 1000 characters")]
        public string? ObstacleDescription { get; set; }

        /// <summary>
        /// Longitude of the obstacle point location (for point obstacles) or first vertex of a line.
        /// </summary>
        [Required]
        public double? Longitude { get; set; }

        /// <summary>
        /// Latitude of the obstacle point location (for point obstacles) or first vertex of a line.
        /// </summary>
        [Required]
        public double? Latitude { get; set; }

        /// <summary>
        /// Optional GeoJSON LineString describing the obstacle footprint. Stored as longtext for length.
        /// </summary>
        [Column(TypeName = "longtext")]
        public string? LineGeoJson { get; set; }

        // Cached values used to avoid repeated JSON parsing when views/controllers request coordinates.
        private IReadOnlyList<GeoCoordinate>? _cachedLine;
        private string? _cachedSource;
        private bool _lineParseFailed;

        /// <summary>
        /// Parsed collection of coordinates derived from <see cref="LineGeoJson"/>. Parsing is cached to
        /// avoid repeated JSON work and to allow validation to detect parse errors.
        /// </summary>
        [NotMapped]
        public IReadOnlyList<GeoCoordinate> LineCoordinates
        {
            get
            {
                if (LineGeoJson == _cachedSource && _cachedLine is not null)
                {
                    return _cachedLine; // Return cached parse result when the source string is unchanged.
                }

                if (string.IsNullOrWhiteSpace(LineGeoJson))
                {
                    _cachedSource = LineGeoJson;
                    _cachedLine = Array.Empty<GeoCoordinate>();
                    _lineParseFailed = false;
                    return _cachedLine;
                }

                _cachedSource = LineGeoJson;
                var parsed = ParseLine(LineGeoJson);
                _lineParseFailed = parsed is null; // Remember parse failures for validation messaging.
                _cachedLine = parsed ?? Array.Empty<GeoCoordinate>();
                return _cachedLine;
            }
        }

        /// <summary>
        /// First coordinate of the line, used to display start marker on map views.
        /// </summary>
        [NotMapped]
        public GeoCoordinate? StartCoordinate => LineCoordinates.FirstOrDefault();

        /// <summary>
        /// Last coordinate of the line, used to display end marker on map views.
        /// </summary>
        [NotMapped]
        public GeoCoordinate? EndCoordinate => LineCoordinates.LastOrDefault();

        /// <summary>
        /// Indicates whether a valid line exists (at least two vertices).
        /// </summary>
        [NotMapped]
        public bool HasLine => LineCoordinates.Count >= 2;

        /// <summary>
        /// Convenience accessor for the number of vertices supplied by the pilot/caseworker.
        /// </summary>
        [NotMapped]
        public int LineVertexCount => LineCoordinates.Count;

        /// <summary>
        /// Calculated line length in meters using the haversine formula. Used in overviews to inform pilots.
        /// </summary>
        [NotMapped]
        public double? LineLengthMeters => HasLine ? CalculateLineLength(LineCoordinates) : null;

        /// <summary>
        /// Lifecycle status set by controllers (Pending/Approved/Declined) to support PRG flow and filters.
        /// </summary>
        public string Status { get; set; } = string.Empty;

        /// <summary>
        /// Email/username of the user who submitted the obstacle; used to enforce pilot-only edits.
        /// </summary>
        public string SubmittedBy { get; set; } = string.Empty;

        /// <summary>
        /// Organization claim captured from the submitting user; used for filtering/reporting.
        /// </summary>
        public string? Organization { get; set; } // Added organization

        /// <summary>
        /// UTC timestamp for when the obstacle was first submitted.
        /// </summary>
        public DateTime SubmittedDate { get; set; }

        /// <summary>
        /// User who last modified the obstacle after submission (audit trail for admins/caseworkers).
        /// </summary>
        public string LastModifiedBy { get; set; } = string.Empty;

        /// <summary>
        /// UTC timestamp of the last modification.
        /// </summary>
        public DateTime LastModifiedDate { get; set; }

        /// <summary>
        /// Caseworker/admin who approved the obstacle (if approved) for audit logging.
        /// </summary>
        public string ApprovedBy { get; set; } = string.Empty;

        /// <summary>
        /// Timestamp when approval occurred.
        /// </summary>
        public DateTime ApprovedDate { get; set; }

        /// <summary>
        /// Free-text reason supplied when declining an obstacle to give feedback to pilots.
        /// </summary>
        public string? DeclineReason { get; set; }

        /// <summary>
        /// Caseworker/admin who declined the obstacle for accountability.
        /// </summary>
        public string DeclinedBy { get; set; } = string.Empty;

        /// <summary>
        /// Timestamp when the obstacle was declined.
        /// </summary>
        public DateTime DeclinedDate { get; set; }

        /// <summary>
        /// Performs custom validation beyond attribute-based checks. Ensures coordinates or line data are
        /// provided and that GeoJSON content is valid. MVC controllers rely on ModelState containing these
        /// results to enforce the PRG pattern and prevent invalid inserts.
        /// </summary>
        /// <param name="validationContext">Supplied by MVC during model validation.</param>
        /// <returns>Enumerable of validation errors to be surfaced in views.</returns>
        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            _ = LineCoordinates; // Trigger parsing so cached flags are set before validation checks.

            if (!_lineParseFailed && string.IsNullOrWhiteSpace(LineGeoJson))
            {
                // For point obstacles we need both latitude and longitude.
                if (!Latitude.HasValue || !Longitude.HasValue)
                {
                    yield return new ValidationResult(
                        "Please click on the map to choose a location.",
                        new[] { nameof(Latitude), nameof(Longitude) });
                }
                yield break;
            }

            if (_lineParseFailed)
            {
                // GeoJSON could not be parsed; inform the user to redraw for safety/accuracy.
                yield return new ValidationResult(
                    "We could not read the drawn line. Please try drawing it again.",
                    new[] { nameof(LineGeoJson) });
                yield break;
            }

            if (!HasLine)
            {
                yield return new ValidationResult(
                    "A line must contain at least two points.",
                    new[] { nameof(LineGeoJson) });
            }
        }

        /// <summary>
        /// Parses a GeoJSON LineString into coordinates. Uses System.Text.Json to avoid dynamic SQL and
        /// stays within managed code for safety. Returns null when invalid so callers can flag ModelState.
        /// </summary>
        /// <param name="geoJson">Raw GeoJSON string supplied by the client.</param>
        /// <returns>List of coordinates or null if parsing fails.</returns>
        private static IReadOnlyList<GeoCoordinate>? ParseLine(string geoJson)
        {
            try
            {
                using var document = JsonDocument.Parse(geoJson);
                var root = document.RootElement;

                if (!root.TryGetProperty("type", out var typeProperty) ||
                    !string.Equals(typeProperty.GetString(), "LineString", StringComparison.OrdinalIgnoreCase))
                {
                    return null; // Only LineString is supported for obstacle footprints.
                }

                if (!root.TryGetProperty("coordinates", out var coordinatesProperty) ||
                    coordinatesProperty.ValueKind != JsonValueKind.Array)
                {
                    return null; // Invalid GeoJSON schema.
                }

                var points = new List<GeoCoordinate>();

                foreach (var coordinate in coordinatesProperty.EnumerateArray())
                {
                    if (coordinate.ValueKind != JsonValueKind.Array || coordinate.GetArrayLength() < 2)
                    {
                        continue; // Skip malformed entries instead of throwing.
                    }

                    var longitude = coordinate[0].GetDouble();
                    var latitude = coordinate[1].GetDouble();
                    points.Add(new GeoCoordinate(latitude, longitude));
                }

                return points;
            }
            catch (JsonException)
            {
                return null; // Parsing failed; caller will surface validation error.
            }
        }

        /// <summary>
        /// Calculates the total distance along a polyline using the haversine formula for accuracy over
        /// the Earth's curvature.
        /// </summary>
        /// <param name="coordinates">Ordered set of coordinates defining the line.</param>
        /// <returns>Length in meters.</returns>
        private static double CalculateLineLength(IReadOnlyList<GeoCoordinate> coordinates)
        {
            double total = 0;
            for (var i = 1; i < coordinates.Count; i++)
            {
                total += HaversineDistance(coordinates[i - 1], coordinates[i]);
            }

            return total;
        }

        /// <summary>
        /// Calculates the distance between two coordinates using the haversine formula.
        /// </summary>
        /// <param name="first">Starting coordinate.</param>
        /// <param name="second">Ending coordinate.</param>
        /// <returns>Distance in meters.</returns>
        private static double HaversineDistance(GeoCoordinate first, GeoCoordinate second)
        {
            const double EarthRadius = 6371000; // meters

            var firstLat = DegreesToRadians(first.Latitude);
            var secondLat = DegreesToRadians(second.Latitude);
            var deltaLat = DegreesToRadians(second.Latitude - first.Latitude);
            var deltaLng = DegreesToRadians(second.Longitude - first.Longitude);

            var a = Math.Sin(deltaLat / 2) * Math.Sin(deltaLat / 2) +
                    Math.Cos(firstLat) * Math.Cos(secondLat) *
                    Math.Sin(deltaLng / 2) * Math.Sin(deltaLng / 2);

            var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            return EarthRadius * c;
        }

        /// <summary>
        /// Converts degrees to radians for trigonometric calculations.
        /// </summary>
        /// <param name="degrees">Degrees value.</param>
        /// <returns>Radians value.</returns>
        private static double DegreesToRadians(double degrees) => degrees * Math.PI / 180.0;

        /// <summary>
        /// Lightweight value type used to represent a coordinate pair. Kept inside the model to keep MVC
        /// binding simple and prevent external modifications.
        /// </summary>
        /// <param name="Latitude">Latitude component.</param>
        /// <param name="Longitude">Longitude component.</param>
        public record GeoCoordinate(double Latitude, double Longitude);
    }
}
